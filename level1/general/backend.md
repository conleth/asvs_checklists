# ASVS LEVEL1 Checklist – General – Backend

_Use during DESIGN and PRE-MERGE review._

- [ ] V1.2.4 – Verify that data selection or database queries (e.g., SQL, HQL, NoSQL, Cypher) use parameterized queries, ORMs, entity frameworks, or are otherwise protected from SQL Injection and other database injection attacks. This is also relevant when writing stored procedures.
- [ ] V10.4.1 – Verify that the authorization server validates redirect URIs based on a client-specific allowlist of pre-registered URIs using exact string comparison.
- [ ] V10.4.2 – Verify that, if the authorization server returns the authorization code in the authorization response, it can be used only once for a token request. For the second valid request with an authorization code that has already been used to issue an access token, the authorization server must reject a token request and revoke any issued tokens related to the authorization code.
- [ ] V10.4.3 – Verify that the authorization code is short-lived. The maximum lifetime can be up to 10 minutes for L1 and L2 applications and up to 1 minute for L3 applications.
- [ ] V10.4.4 – Verify that for a given client, the authorization server only allows the usage of grants that this client needs to use. Note that the grants 'token' (Implicit flow) and 'password' (Resource Owner Password Credentials flow) must no longer be used.
- [ ] V10.4.5 – Verify that the authorization server mitigates refresh token replay attacks for public clients, preferably using sender-constrained refresh tokens, i.e., Demonstrating Proof of Possession (DPoP) or Certificate-Bound Access Tokens using mutual TLS (mTLS). For L1 and L2 applications, refresh token rotation may be used. If refresh token rotation is used, the authorization server must invalidate the refresh token after usage, and revoke all refresh tokens for that authorization if an already used and invalidated refresh token is provided.
- [ ] V11.4.1 – Verify that only approved hash functions are used for general cryptographic use cases, including digital signatures, HMAC, KDF, and random bit generation. Disallowed hash functions, such as MD5, must not be used for any cryptographic purpose.
- [ ] V14.2.1 – Verify that sensitive data is only sent to the server in the HTTP message body or header fields, and that the URL and query string do not contain sensitive information, such as an API key or session token.
- [ ] V14.3.1 – Verify that authenticated data is cleared from client storage, such as the browser DOM, after the client or session is terminated. The 'Clear-Site-Data' HTTP response header field may be able to help with this but the client-side should also be able to clear up if the server connection is not available when the session is terminated.
- [ ] V2.3.1 – Verify that the application will only process business logic flows for the same user in the expected sequential step order and without skipping steps.
- [ ] V6.4.2 – Verify that password hints or knowledge-based authentication (so-called "secret questions") are not present.
- [ ] V7.2.1 – Verify that the application performs all session token verification using a trusted, backend service.
- [ ] V7.2.2 – Verify that the application uses either self-contained or reference tokens that are dynamically generated for session management, i.e. not using static API secrets and keys.
- [ ] V7.2.3 – Verify that if reference tokens are used to represent user sessions, they are unique and generated using a cryptographically secure pseudo-random number generator (CSPRNG) and possess at least 128 bits of entropy.
- [ ] V7.2.4 – Verify that the application generates a new session token on user authentication, including re-authentication, and terminates the current session token.
- [ ] V7.4.1 – Verify that when session termination is triggered (such as logout or expiration), the application disallows any further use of the session. For reference tokens or stateful sessions, this means invalidating the session data at the application backend. Applications using self-contained tokens will need a solution such as maintaining a list of terminated tokens, disallowing tokens produced before a per-user date and time or rotating a per-user signing key.
- [ ] V7.4.2 – Verify that the application terminates all active sessions when a user account is disabled or deleted (such as an employee leaving the company).
- [ ] V8.1.1 – Verify that authorization documentation defines rules for restricting function-level and data-specific access based on consumer permissions and resource attributes.
- [ ] V8.2.2 – Verify that the application ensures that data-specific access is restricted to consumers with explicit permissions to specific data items to mitigate insecure direct object reference (IDOR) and broken object level authorization (BOLA).

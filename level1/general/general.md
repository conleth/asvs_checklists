# ASVS LEVEL1 Checklist – General – General

_Use during DESIGN and PRE-MERGE review._

- [ ] V1.2.5 – Verify that the application protects against OS command injection and that operating system calls use parameterized OS queries or use contextual command line output encoding.
- [ ] V11.3.1 – Verify that insecure block modes (e.g., ECB) and weak padding schemes (e.g., PKCS#1 v1.5) are not used.
- [ ] V11.3.2 – Verify that only approved ciphers and modes such as AES with GCM are used.
- [ ] V12.1.1 – Verify that only the latest recommended versions of the TLS protocol are enabled, such as TLS 1.2 and TLS 1.3. The latest version of the TLS protocol must be the preferred option.
- [ ] V12.2.1 – Verify that TLS is used for all connectivity between a client and external facing, HTTP-based services, and does not fall back to insecure or unencrypted communications.
- [ ] V12.2.2 – Verify that external facing services use publicly trusted TLS certificates.
- [ ] V13.4.1 – Verify that the application is deployed either without any source control metadata, including the .git or .svn folders, or in a way that these folders are inaccessible both externally and to the application itself.
- [ ] V15.1.1 – Verify that application documentation defines risk based remediation time frames for 3rd party component versions with vulnerabilities and for updating libraries in general, to minimize the risk from these components.
- [ ] V15.2.1 – Verify that the application only contains components which have not breached the documented update and remediation time frames.
- [ ] V2.1.1 – Verify that the application's documentation defines input validation rules for how to check the validity of data items against an expected structure. This could be common data formats such as credit card numbers, email addresses, telephone numbers, or it could be an internal data format.
- [ ] V2.2.1 – Verify that input is validated to enforce business or functional expectations for that input. This should either use positive validation against an allow list of values, patterns, and ranges, or be based on comparing the input to an expected structure and logical limits according to predefined rules. For L1, this can focus on input which is used to make specific business or security decisions. For L2 and up, this should apply to all input.
- [ ] V2.2.2 – Verify that the application is designed to enforce input validation at a trusted service layer. While client-side validation improves usability and should be encouraged, it must not be relied upon as a security control.
- [ ] V3.3.1 – Verify that cookies have the 'Secure' attribute set, and if the '\__Host-' prefix is not used for the cookie name, the '__Secure-' prefix must be used for the cookie name.
- [ ] V3.4.2 – Verify that the Cross-Origin Resource Sharing (CORS) Access-Control-Allow-Origin header field is a fixed value by the application, or if the Origin HTTP request header field value is used, it is validated against an allowlist of trusted origins. When 'Access-Control-Allow-Origin: *' needs to be used, verify that the response does not include any sensitive information.
- [ ] V3.5.3 – Verify that HTTP requests to sensitive functionality use appropriate HTTP methods such as POST, PUT, PATCH, or DELETE, and not methods defined by the HTTP specification as "safe" such as HEAD, OPTIONS, or GET. Alternatively, strict validation of the Sec-Fetch-* request header fields can be used to ensure that the request did not originate from an inappropriate cross-origin call, a navigation request, or a resource load (such as an image source) where this is not expected.
- [ ] V4.1.1 – Verify that every HTTP response with a message body contains a Content-Type header field that matches the actual content of the response, including the charset parameter to specify safe character encoding (e.g., UTF-8, ISO-8859-1) according to IANA Media Types, such as "text/", "/+xml" and "/xml".
- [ ] V4.4.1 – Verify that WebSocket over TLS (WSS) is used for all WebSocket connections.
- [ ] V5.2.1 – Verify that the application will only accept files of a size which it can process without causing a loss of performance or a denial of service attack.
- [ ] V5.2.2 – Verify that when the application accepts a file, either on its own or within an archive such as a zip file, it checks if the file extension matches an expected file extension and validates that the contents correspond to the type represented by the extension. This includes, but is not limited to, checking the initial 'magic bytes', performing image re-writing, and using specialized libraries for file content validation. For L1, this can focus just on files which are used to make specific business or security decisions. For L2 and up, this must apply to all files being accepted.
- [ ] V5.3.1 – Verify that files uploaded or generated by untrusted input and stored in a public folder, are not executed as server-side program code when accessed directly with an HTTP request.
- [ ] V5.3.2 – Verify that when the application creates file paths for file operations, instead of user-submitted filenames, it uses internally generated or trusted data, or if user-submitted filenames or file metadata must be used, strict validation and sanitization must be applied. This is to protect against path traversal, local or remote file inclusion (LFI, RFI), and server-side request forgery (SSRF) attacks.
- [ ] V6.2.1 – Verify that user set passwords are at least 8 characters in length although a minimum of 15 characters is strongly recommended.
- [ ] V6.2.2 – Verify that users can change their password.
- [ ] V6.2.4 – Verify that passwords submitted during account registration or password change are checked against an available set of, at least, the top 3000 passwords which match the application's password policy, e.g. minimum length.
- [ ] V6.2.6 – Verify that password input fields use type=password to mask the entry. Applications may allow the user to temporarily view the entire masked password, or the last typed character of the password.
- [ ] V6.2.8 – Verify that the application verifies the user's password exactly as received from the user, without any modifications such as truncation or case transformation.
- [ ] V6.3.1 – Verify that controls to prevent attacks such as credential stuffing and password brute force are implemented according to the application's security documentation.
- [ ] V6.3.2 – Verify that default user accounts (e.g., "root", "admin", or "sa") are not present in the application or are disabled.
- [ ] V9.1.1 – Verify that self-contained tokens are validated using their digital signature or MAC to protect against tampering before accepting the token's contents.
- [ ] V9.1.2 – Verify that only algorithms on an allowlist can be used to create and verify self-contained tokens, for a given context. The allowlist must include the permitted algorithms, ideally only either symmetric or asymmetric algorithms, and must not include the 'None' algorithm. If both symmetric and asymmetric must be supported, additional controls will be needed to prevent key confusion.
- [ ] V9.1.3 – Verify that key material that is used to validate self-contained tokens is from trusted pre-configured sources for the token issuer, preventing attackers from specifying untrusted sources and keys. For JWTs and other JWS structures, headers such as 'jku', 'x5u', and 'jwk' must be validated against an allowlist of trusted sources.
- [ ] V9.2.1 – Verify that, if a validity time span is present in the token data, the token and its content are accepted only if the verification time is within this validity time span. For example, for JWTs, the claims 'nbf' and 'exp' must be verified.

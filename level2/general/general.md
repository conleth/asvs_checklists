# ASVS LEVEL2 Checklist – General – General

_Use during DESIGN and PRE-MERGE review._

- [ ] V1.1.1 – Verify that input is decoded or unescaped into a canonical form only once, it is only decoded when encoded data in that form is expected, and that this is done before processing the input further, for example it is not performed after input validation or sanitization.
- [ ] V1.2.6 – Verify that the application protects against LDAP injection vulnerabilities, or that specific security controls to prevent LDAP injection have been implemented.
- [ ] V1.2.7 – Verify that the application is protected against XPath injection attacks by using query parameterization or precompiled queries.
- [ ] V1.2.9 – Verify that the application escapes special characters in regular expressions (typically using a backslash) to prevent them from being misinterpreted as metacharacters.
- [ ] V1.3.10 – Verify that format strings which might resolve in an unexpected or malicious way when used are sanitized before being processed.
- [ ] V1.3.11 – Verify that the application sanitizes user input before passing to mail systems to protect against SMTP or IMAP injection.
- [ ] V1.3.3 – Verify that data being passed to a potentially dangerous context is sanitized beforehand to enforce safety measures, such as only allowing characters which are safe for this context and trimming input which is too long.
- [ ] V1.3.4 – Verify that user-supplied Scalable Vector Graphics (SVG) scriptable content is validated or sanitized to contain only tags and attributes (such as draw graphics) that are safe for the application, e.g., do not contain scripts and foreignObject.
- [ ] V1.3.5 – Verify that the application sanitizes or disables user-supplied scriptable or expression template language content, such as Markdown, CSS or XSL stylesheets, BBCode, or similar.
- [ ] V1.3.9 – Verify that the application sanitizes content before it is sent to memcache to prevent injection attacks.
- [ ] V1.4.1 – Verify that the application uses memory-safe string, safer memory copy and pointer arithmetic to detect or prevent stack, buffer, or heap overflows.
- [ ] V1.4.2 – Verify that sign, range, and input validation techniques are used to prevent integer overflows.
- [ ] V1.4.3 – Verify that dynamically allocated memory and resources are released, and that references or pointers to freed memory are removed or set to null to prevent dangling pointers and use-after-free vulnerabilities.
- [ ] V10.4.8 – Verify that refresh tokens have an absolute expiration, including if sliding refresh token expiration is applied.
- [ ] V10.5.4 – Verify that the client validates that the ID Token is intended to be used for that client (audience) by checking that the 'aud' claim from the token is equal to the 'client_id' value for the client.
- [ ] V10.5.5 – Verify that, when using OIDC back-channel logout, the relying party mitigates denial of service through forced logout and cross-JWT confusion in the logout flow. The client must verify that the logout token is correctly typed with a value of 'logout+jwt', contains the 'event' claim with the correct member name, and does not contain a 'nonce' claim. Note that it is also recommended to have a short expiration (e.g., 2 minutes).
- [ ] V11.3.3 – Verify that encrypted data is protected against unauthorized modification preferably by using an approved authenticated encryption method or by combining an approved encryption method with an approved MAC algorithm.
- [ ] V12.3.2 – Verify that TLS clients validate certificates received before communicating with a TLS server.
- [ ] V12.3.3 – Verify that TLS or another appropriate transport encryption mechanism used for all connectivity between internal, HTTP-based services within the application, and does not fall back to insecure or unencrypted communications.
- [ ] V12.3.4 – Verify that TLS connections between internal services use trusted certificates. Where internally generated or self-signed certificates are used, the consuming service must be configured to only trust specific internal CAs and specific self-signed certificates.
- [ ] V13.1.1 – Verify that all communication needs for the application are documented. This must include external services which the application relies upon and cases where an end user might be able to provide an external location to which the application will then connect.
- [ ] V13.2.4 – Verify that an allowlist is used to define the external resources or systems with which the application is permitted to communicate (e.g., for outbound requests, data loads, or file access). This allowlist can be implemented at the application layer, web server, firewall, or a combination of different layers.
- [ ] V13.2.5 – Verify that the web or application server is configured with an allowlist of resources or systems to which the server can send requests or load data or files from.
- [ ] V13.3.2 – Verify that access to secret assets adheres to the principle of least privilege.
- [ ] V13.4.2 – Verify that debug modes are disabled for all components in production environments to prevent exposure of debugging features and information leakage.
- [ ] V13.4.3 – Verify that web servers do not expose directory listings to clients unless explicitly intended.
- [ ] V13.4.4 – Verify that using the HTTP TRACE method is not supported in production environments, to avoid potential information leakage.
- [ ] V14.2.2 – Verify that the application prevents sensitive data from being cached in server components, such as load balancers and application caches, or ensures that the data is securely purged after use.
- [ ] V14.2.3 – Verify that defined sensitive data is not sent to untrusted parties (e.g., user trackers) to prevent unwanted collection of data outside of the application's control.
- [ ] V14.2.4 – Verify that controls around sensitive data related to encryption, integrity verification, retention, how the data is to be logged, access controls around sensitive data in logs, privacy and privacy-enhancing technologies, are implemented as defined in the documentation for the specific data's protection level.
- [ ] V15.2.2 – Verify that the application has implemented defenses against loss of availability due to functionality which is time-consuming or resource-demanding, based on the documented security decisions and strategies for this.
- [ ] V15.3.2 – Verify that where the application backend makes calls to external URLs, it is configured to not follow redirects unless it is intended functionality.
- [ ] V15.3.3 – Verify that the application has countermeasures to protect against mass assignment attacks by limiting allowed fields per controller and action, e.g., it is not possible to insert or update a field value when it was not intended to be part of that action.
- [ ] V15.3.5 – Verify that the application explicitly ensures that variables are of the correct type and performs strict equality and comparator operations. This is to avoid type juggling or type confusion vulnerabilities caused by the application code making an assumption about a variable type.
- [ ] V15.3.7 – Verify that the application has defenses against HTTP parameter pollution attacks, particularly if the application framework makes no distinction about the source of request parameters (query string, body parameters, cookies, or header fields).
- [ ] V16.1.1 – Verify that an inventory exists documenting the logging performed at each layer of the application's technology stack, what events are being logged, log formats, where that logging is stored, how it is used, how access to it is controlled, and for how long logs are kept.
- [ ] V16.2.1 – Verify that each log entry includes necessary metadata (such as when, where, who, what) that would allow for a detailed investigation of the timeline when an event happens.
- [ ] V16.2.2 – Verify that time sources for all logging components are synchronized, and that timestamps in security event metadata use UTC or include an explicit time zone offset. UTC is recommended to ensure consistency across distributed systems and to prevent confusion during daylight saving time transitions.
- [ ] V16.2.3 – Verify that the application only stores or broadcasts logs to the files and services that are documented in the log inventory.
- [ ] V16.3.4 – Verify that the application logs unexpected errors and security control failures such as backend TLS failures.
- [ ] V16.4.1 – Verify that all logging components appropriately encode data to prevent log injection.
- [ ] V16.4.2 – Verify that logs are protected from unauthorized access and cannot be modified.
- [ ] V16.4.3 – Verify that logs are securely transmitted to a logically separate system for analysis, detection, alerting, and escalation. The aim is to ensure that if the application is breached, the logs are not compromised.
- [ ] V16.5.1 – Verify that a generic message is returned to the consumer when an unexpected or security-sensitive error occurs, ensuring no exposure of sensitive internal system data such as stack traces, queries, secret keys, and tokens.
- [ ] V16.5.3 – Verify that the application fails gracefully and securely, including when an exception occurs, preventing fail-open conditions such as processing a transaction despite errors resulting from validation logic.
- [ ] V17.1.1 – Verify that the Traversal Using Relays around NAT (TURN) service only allows access to IP addresses that are not reserved for special purposes (e.g., internal networks, broadcast, loopback). Note that this applies to both IPv4 and IPv6 addresses.
- [ ] V17.2.4 – Verify that the media server is able to continue processing incoming media traffic when encountering malformed Secure Real-time Transport Protocol (SRTP) packets.
- [ ] V17.3.2 – Verify that the signaling server is able to continue processing legitimate signaling messages when encountering malformed signaling message that could cause a denial of service condition. This could include implementing input validation, safely handling integer overflows, preventing buffer overflows, and employing other robust error-handling techniques.
- [ ] V2.1.2 – Verify that the application's documentation defines how to validate the logical and contextual consistency of combined data items, such as checking that suburb and ZIP code match.
- [ ] V2.2.3 – Verify that the application ensures that combinations of related data items are reasonable according to the pre-defined rules.
- [ ] V2.4.1 – Verify that anti-automation controls are in place to protect against excessive calls to application functions that could lead to data exfiltration, garbage-data creation, quota exhaustion, rate-limit breaches, denial-of-service, or overuse of costly resources.
- [ ] V3.3.3 – Verify that cookies have the '__Host-' prefix for the cookie name unless they are explicitly designed to be shared with other hosts.
- [ ] V3.5.5 – Verify that messages received by the postMessage interface are discarded if the origin of the message is not trusted, or if the syntax of the message is invalid.
- [ ] V4.1.3 – Verify that any HTTP header field used by the application and set by an intermediary layer, such as a load balancer, a web proxy, or a backend-for-frontend service, cannot be overridden by the end-user. Example headers might include X-Real-IP, X-Forwarded-*, or X-User-ID.
- [ ] V4.2.1 – Verify that all application components (including load balancers, firewalls, and application servers) determine boundaries of incoming HTTP messages using the appropriate mechanism for the HTTP version to prevent HTTP request smuggling. In HTTP/1.x, if a Transfer-Encoding header field is present, the Content-Length header must be ignored per RFC 2616. When using HTTP/2 or HTTP/3, if a Content-Length header field is present, the receiver must ensure that it is consistent with the length of the DATA frames.
- [ ] V4.4.2 – Verify that, during the initial HTTP WebSocket handshake, the Origin header field is checked against a list of origins allowed for the application.
- [ ] V5.1.1 – Verify that the documentation defines the permitted file types, expected file extensions, and maximum size (including unpacked size) for each upload feature. Additionally, ensure that the documentation specifies how files are made safe for end-users to download and process, such as how the application behaves when a malicious file is detected.
- [ ] V5.2.3 – Verify that the application checks compressed files (e.g., zip, gz, docx, odt) against maximum allowed uncompressed size and against maximum number of files before uncompressing the file.
- [ ] V5.4.1 – Verify that the application validates or ignores user-submitted filenames, including in a JSON, JSONP, or URL parameter and specifies a filename in the Content-Disposition header field in the response.
- [ ] V5.4.2 – Verify that file names served (e.g., in HTTP response header fields or email attachments) are encoded or sanitized (e.g., following RFC 6266) to preserve document structure and prevent injection attacks.
- [ ] V5.4.3 – Verify that files obtained from untrusted sources are scanned by antivirus scanners to prevent serving of known malicious content.
- [ ] V6.1.2 – Verify that a list of context-specific words is documented in order to prevent their use in passwords. The list could include permutations of organization names, product names, system identifiers, project codenames, department or role names, and similar.
- [ ] V6.2.11 – Verify that the documented list of context specific words is used to prevent easy to guess passwords being created.
- [ ] V6.2.12 – Verify that passwords submitted during account registration or password changes are checked against a set of breached passwords.
- [ ] V6.2.9 – Verify that passwords of at least 64 characters are permitted.
- [ ] V8.4.1 – Verify that multi-tenant applications use cross-tenant controls to ensure consumer operations will never affect tenants with which they do not have permissions to interact.
- [ ] V9.2.3 – Verify that the service only accepts tokens which are intended for use with that service (audience). For JWTs, this can be achieved by validating the 'aud' claim against an allowlist defined in the service.
